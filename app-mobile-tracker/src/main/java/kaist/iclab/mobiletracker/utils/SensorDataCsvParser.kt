package kaist.iclab.mobiletracker.utils

import android.util.Log
import kaist.iclab.mobiletracker.config.AppConfig
import kaist.iclab.mobiletracker.data.watch.AccelerometerSensorData
import kaist.iclab.mobiletracker.data.watch.EDASensorData
import kaist.iclab.mobiletracker.data.watch.HeartRateSensorData
import kaist.iclab.mobiletracker.data.watch.LocationSensorData
import kaist.iclab.mobiletracker.data.watch.PPGSensorData
import kaist.iclab.mobiletracker.data.watch.SkinTemperatureSensorData

/**
 * Parser for sensor data in CSV format received from wearable devices.
 * 
 * Supports parsing multiple sensor types from a single CSV string:
 * - accelerometer: id,received,timestamp,x,y,z
 * - ppg: id,received,timestamp,green,greenStatus,red,redStatus,ir,irStatus
 * - heartRate: id,received,timestamp,hr,hrStatus,ibi,ibiStatus (ibi and ibiStatus are semicolon-separated lists)
 * - skinTemperature: id,received,timestamp,ambientTemp,objectTemp,status
 * - eda: id,received,timestamp,skinConductance,status
 * - location: id,received,timestamp,latitude,longitude,altitude,speed,accuracy
 */
object SensorDataCsvParser {
    
    /**
     * Parse CSV data to extract location sensor entries
     * 
     * @param csvData The raw CSV string containing sensor data
     * @return List of parsed LocationSensorData, empty list if parsing fails
     */
    fun parseLocationCsv(csvData: String): List<LocationSensorData> {
        val locationDataList = mutableListOf<LocationSensorData>()
        
        try {
            val lines = csvData.lines()
            var inLocationSection = false
            var headerFound = false
            
            for (line in lines) {
                val trimmedLine = line.trim()
                
                // Check if we're entering the location section
                if (trimmedLine.equals("location", ignoreCase = true)) {
                    inLocationSection = true
                    headerFound = false
                    continue
                }
                
                // If we're in location section, look for header
                if (inLocationSection && !headerFound) {
                    if (trimmedLine.contains("id,received,timestamp,latitude,longitude,altitude,speed,accuracy", ignoreCase = true)) {
                        headerFound = true
                        continue
                    }
                }
                
                // If header found, parse data rows
                if (inLocationSection && headerFound) {
                    // Check if we've moved to a new section (non-empty line that doesn't start with a number)
                    if (trimmedLine.isNotEmpty() && !trimmedLine.first().isDigit() && !trimmedLine.equals("location", ignoreCase = true)) {
                        // Likely moved to next section
                        break
                    }
                    
                    // Skip empty lines
                    if (trimmedLine.isEmpty()) {
                        continue
                    }
                    
                    // Parse location data row
                    val locationData = parseLocationRow(trimmedLine)
                    locationData?.let { locationDataList.add(it) }
                }
            }
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing location CSV: ${e.message}", e)
        }
        
        return locationDataList
    }

    /**
     * Parse a single location data row
     * Format: id,received,timestamp,latitude,longitude,altitude,speed,accuracy
     * 
     * Maps to LocationSensorData:
     * - uuid: auto-generated in service (not in CSV)
     * - timestamp: from CSV column 2 (index 2)
     * - latitude: from CSV column 3 (index 3, Double)
     * - longitude: from CSV column 4 (index 4, Double)
     * - altitude: from CSV column 5 (index 5, Double)
     * - speed: from CSV column 6 (index 6, Float)
     * - accuracy: from CSV column 7 (index 7, Float)
     * - created_at: auto-generated by Supabase (not sent)
     * 
     * @param row A single CSV row string
     * @return Parsed LocationSensorData or null if parsing fails
     */
    private fun parseLocationRow(row: String): LocationSensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 8) {
                // Skip id (index 0) and received (index 1) as they're not needed for Supabase
                val timestamp = parts[2].toLongOrNull() ?: return null
                val latitude = parts[3].toDoubleOrNull() ?: return null
                val longitude = parts[4].toDoubleOrNull() ?: return null
                val altitude = parts[5].toDoubleOrNull() ?: return null
                val speed = parts[6].toFloatOrNull() ?: return null
                val accuracy = parts[7].toFloatOrNull() ?: return null
                
                LocationSensorData(
                    uuid = null, // Will be set by service
                    timestamp = timestamp,
                    latitude = latitude,
                    longitude = longitude,
                    altitude = altitude,
                    speed = speed,
                    accuracy = accuracy,
                    created_at = null // Auto-generated by Supabase, not sent
                )
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing location row: ${e.message}", e)
            null
        }
    }

    /**
     * Parse CSV data to extract accelerometer sensor entries
     * CSV format: accelerometer\nid,received,timestamp,x,y,z\n...
     */
    fun parseAccelerometerCsv(csvData: String): List<AccelerometerSensorData> {
        return parseSensorSection(
            csvData = csvData,
            sectionName = "accelerometer",
            headerPattern = "id,received,timestamp,x,y,z",
            rowParser = ::parseAccelerometerRow
        )
    }

    /**
     * Parse CSV data to extract PPG sensor entries
     * CSV format: ppg\nid,received,timestamp,green,greenStatus,red,redStatus,ir,irStatus\n...
     */
    fun parsePPGCsv(csvData: String): List<PPGSensorData> {
        return parseSensorSection(
            csvData = csvData,
            sectionName = "ppg",
            headerPattern = "id,received,timestamp,green,greenStatus,red,redStatus,ir,irStatus",
            rowParser = ::parsePPGRow
        )
    }

    /**
     * Parse CSV data to extract heart rate sensor entries
     * CSV format: heartRate\nid,received,timestamp,hr,hrStatus,ibi,ibiStatus\n...
     * Note: ibi and ibiStatus are semicolon-separated lists
     */
    fun parseHeartRateCsv(csvData: String): List<HeartRateSensorData> {
        return parseSensorSection(
            csvData = csvData,
            sectionName = "heartRate",
            headerPattern = "id,received,timestamp,hr,hrStatus,ibi,ibiStatus",
            rowParser = ::parseHeartRateRow
        )
    }

    /**
     * Parse CSV data to extract skin temperature sensor entries
     * CSV format: skinTemperature\nid,received,timestamp,ambientTemp,objectTemp,status\n...
     */
    fun parseSkinTemperatureCsv(csvData: String): List<SkinTemperatureSensorData> {
        return parseSensorSection(
            csvData = csvData,
            sectionName = "skinTemperature",
            headerPattern = "id,received,timestamp,ambientTemp,objectTemp,status",
            rowParser = ::parseSkinTemperatureRow
        )
    }

    /**
     * Parse CSV data to extract EDA sensor entries
     * CSV format: eda\nid,received,timestamp,skinConductance,status\n...
     */
    fun parseEDACsv(csvData: String): List<EDASensorData> {
        return parseSensorSection(
            csvData = csvData,
            sectionName = "eda",
            headerPattern = "id,received,timestamp,skinConductance,status",
            rowParser = ::parseEDARow
        )
    }

    /**
     * Generic parser for sensor sections in CSV
     */
    private fun <T> parseSensorSection(
        csvData: String,
        sectionName: String,
        headerPattern: String,
        rowParser: (String) -> T?
    ): List<T> {
        val dataList = mutableListOf<T>()
        
        try {
            val lines = csvData.lines()
            var inSection = false
            var headerFound = false
            
            for (line in lines) {
                val trimmedLine = line.trim()
                
                // Check if we're entering the section
                if (trimmedLine.equals(sectionName, ignoreCase = true)) {
                    inSection = true
                    headerFound = false
                    continue
                }
                
                // If we're in section, look for header
                if (inSection && !headerFound) {
                    if (trimmedLine.contains(headerPattern, ignoreCase = true)) {
                        headerFound = true
                        continue
                    }
                }
                
                // If header found, parse data rows
                if (inSection && headerFound) {
                    // Check if we've moved to a new section
                    if (trimmedLine.isNotEmpty() && 
                        !trimmedLine.first().isDigit() && 
                        !trimmedLine.equals(sectionName, ignoreCase = true) &&
                        !isKnownSectionHeader(trimmedLine)) {
                        break
                    }
                    
                    // Skip empty lines
                    if (trimmedLine.isEmpty()) {
                        continue
                    }
                    
                    // Parse data row
                    val data = rowParser(trimmedLine)
                    data?.let { dataList.add(it) }
                }
            }
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing $sectionName CSV: ${e.message}", e)
        }
        
        return dataList
    }

    /**
     * Check if a line is a known section header
     */
    private fun isKnownSectionHeader(line: String): Boolean {
        val knownSections = listOf(
            "accelerometer", "ppg", "heartRate", "skinTemperature", 
            "eda", "location"
        )
        return knownSections.any { line.equals(it, ignoreCase = true) }
    }

    /**
     * Parse a single accelerometer data row
     * Format: id,received,timestamp,x,y,z
     */
    private fun parseAccelerometerRow(row: String): AccelerometerSensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 6) {
                val timestamp = parts[2].toLongOrNull() ?: return null
                val x = parts[3].toFloatOrNull() ?: return null
                val y = parts[4].toFloatOrNull() ?: return null
                val z = parts[5].toFloatOrNull() ?: return null
                
                AccelerometerSensorData(
                    uuid = null,
                    timestamp = timestamp,
                    x = x,
                    y = y,
                    z = z,
                    created_at = null
                )
            } else null
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing accelerometer row: ${e.message}", e)
            null
        }
    }

    /**
     * Parse a single PPG data row
     * Format: id,received,timestamp,green,greenStatus,red,redStatus,ir,irStatus
     */
    private fun parsePPGRow(row: String): PPGSensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 9) {
                val timestamp = parts[2].toLongOrNull() ?: return null
                val green = parts[3].toIntOrNull() ?: return null
                val greenStatus = parts[4].toIntOrNull() ?: return null
                val red = parts[5].toIntOrNull() ?: return null
                val redStatus = parts[6].toIntOrNull() ?: return null
                val ir = parts[7].toIntOrNull() ?: return null
                val irStatus = parts[8].toIntOrNull() ?: return null
                
                PPGSensorData(
                    uuid = null,
                    timestamp = timestamp,
                    green = green,
                    greenStatus = greenStatus,
                    red = red,
                    redStatus = redStatus,
                    ir = ir,
                    irStatus = irStatus,
                    created_at = null
                )
            } else null
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing PPG row: ${e.message}", e)
            null
        }
    }

    /**
     * Parse a single heart rate data row
     * Format: id,received,timestamp,hr,hrStatus,ibi,ibiStatus
     * Note: ibi and ibiStatus are semicolon-separated lists
     */
    private fun parseHeartRateRow(row: String): HeartRateSensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 7) {
                val timestamp = parts[2].toLongOrNull() ?: return null
                val hr = parts[3].toIntOrNull() ?: return null
                val hrStatus = parts[4].toIntOrNull() ?: return null
                
                // Parse semicolon-separated lists
                val ibi = parts[5].split(";").mapNotNull { it.trim().toIntOrNull() }
                val ibiStatus = parts[6].split(";").mapNotNull { it.trim().toIntOrNull() }
                
                HeartRateSensorData(
                    uuid = null,
                    timestamp = timestamp,
                    hr = hr,
                    hrStatus = hrStatus,
                    ibi = ibi,
                    ibiStatus = ibiStatus,
                    created_at = null
                )
            } else null
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing heart rate row: ${e.message}", e)
            null
        }
    }

    /**
     * Parse a single skin temperature data row
     * Format: id,received,timestamp,ambientTemp,objectTemp,status
     */
    private fun parseSkinTemperatureRow(row: String): SkinTemperatureSensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 6) {
                val timestamp = parts[2].toLongOrNull() ?: return null
                val ambientTemp = parts[3].toFloatOrNull() ?: return null
                val objectTemp = parts[4].toFloatOrNull() ?: return null
                val status = parts[5].toIntOrNull() ?: return null
                
                SkinTemperatureSensorData(
                    uuid = null,
                    timestamp = timestamp,
                    ambientTemp = ambientTemp,
                    objectTemp = objectTemp,
                    status = status,
                    created_at = null
                )
            } else null
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing skin temperature row: ${e.message}", e)
            null
        }
    }

    /**
     * Parse a single EDA data row
     * Format: id,received,timestamp,skinConductance,status
     */
    private fun parseEDARow(row: String): EDASensorData? {
        return try {
            val parts = row.split(",").map { it.trim() }
            if (parts.size >= 5) {
                val timestamp = parts[2].toLongOrNull() ?: return null
                val skinConductance = parts[3].toFloatOrNull() ?: return null
                val status = parts[4].toIntOrNull() ?: return null
                
                EDASensorData(
                    uuid = null,
                    timestamp = timestamp,
                    skinConductance = skinConductance,
                    status = status,
                    created_at = null
                )
            } else null
        } catch (e: Exception) {
            Log.e(AppConfig.LogTags.PHONE_BLE, "Error parsing EDA row: ${e.message}", e)
            null
        }
    }
}

